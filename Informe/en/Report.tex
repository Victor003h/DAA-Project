\documentclass[12pt,a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{setspace}
\usepackage{algorithm}
\usepackage{algpseudocode}

\geometry{margin=2.5cm}
\onehalfspacing


\title{\textbf{Connecting the University of Havana:}\\
Design and Analysis of a Degree-Constrained Fiber Optic Network}
\author{José Agustín Del Toro González}
\date{}

\begin{document}
\maketitle

\section{Introduction}

The modernization of network infrastructure is a fundamental requirement for the
academic and scientific development of modern universities. In this context, the
University of Havana, with technical support from ETECSA, aims to interconnect its main
buildings through a high-speed fiber optic network.

This work addresses the problem from the perspective of \textit{Design and Analysis of
Algorithms}, modeling it as a combinatorial optimization problem on graphs subject to
real-world technical constraints. The goal is to design a minimum-cost network that
connects all buildings, avoids unnecessary cycles, and respects the limited number of
ports available at each network device.

\section{Informal Problem Description}

A set of university buildings must be interconnected using fiber optic links. Each possible
connection has an associated installation cost, and each building is equipped with a
network device that supports only a limited number of direct connections.

The objective is to select a subset of connections that:
\begin{itemize}
    \item Connects all buildings.
    \item Contains no cycles.
    \item Respects degree constraints at each building.
    \item Minimizes the total installation cost.
\end{itemize}

\section{Mathematical Formalization}

\subsection{Graph Model}

The problem is modeled as an undirected weighted graph:
\[
G = (V, E, w)
\]
where:
\begin{itemize}
    \item $V$ represents the set of buildings.
    \item $E$ represents the set of possible fiber connections.
    \item $w: E \rightarrow \mathbb{R}^+$ assigns a cost to each connection.
\end{itemize}

Each vertex $v \in V$ is associated with a degree bound $b(v)$ representing the maximum
number of allowed connections.

\subsection{Problem Definition}

Find a subset of edges $T \subseteq E$ such that:
\begin{enumerate}
    \item $(V,T)$ is a spanning tree.
    \item $\deg_T(v) \leq b(v)$ for all $v \in V$.
    \item The total cost $\sum_{e \in T} w(e)$ is minimized.
\end{enumerate}

This problem is known as the \textbf{Degree-Constrained Minimum Spanning Tree (DC-MST)}
problem.
\section{Computational Complexity Analysis}

In this section, the computational complexity of the DC-MST problem is rigorously
studied, with the aim of theoretically justifying the algorithmic decisions adopted
throughout the remainder of this work.

\subsection{Theoretical Framework}

This section provides a rigorous analysis of the computational complexity of the
\textit{Degree-Constrained Minimum Spanning Tree} (DC-MST) problem. The objective is
to justify, from the standpoint of computational complexity theory, why it is not
reasonable to expect efficient exact algorithms for its resolution in the general
case, and to provide a theoretical foundation for the use of heuristics and
approximation methods.

\subsection{Membership of DC-MST in NP}

A decision problem belongs to the class $\mathbf{P}$ if there exists a deterministic
algorithm that solves it in polynomial time with respect to the input size. A problem
belongs to the class $\mathbf{NP}$ if, given a candidate solution, it can be verified
in polynomial time.

A problem is said to be \textbf{NP-hard} if every problem in $\mathbf{NP}$ can be
reduced to it through a transformation computable in polynomial time. If, in
addition, the problem belongs to $\mathbf{NP}$, it is said to be
\textbf{NP-complete}.

The classical Minimum Spanning Tree (MST) problem belongs to the class $\mathbf{P}$.
However, as shown below, the introduction of constraints on the maximum degree of
vertices radically alters its computational complexity.

\subsection{Canonical Problem Chosen: Hamiltonian Path}

To prove the NP-hardness of the DC-MST problem, a polynomial-time reduction is employed
from the canonical problem \textbf{Hamiltonian Path (HP)}.

\textbf{Definition (Hamiltonian Path).}  
Given an undirected graph $G = (V,E)$, determine whether there exists a simple path
that visits all vertices exactly once.

This problem is known to be \textbf{NP-complete}.

The choice of Hamiltonian Path is natural for the following structural reasons:

\begin{itemize}
    \item A path is a connected and acyclic graph, that is, a tree.
    \item In a path, internal vertices have degree exactly 2.
    \item The endpoints of the path have degree exactly 1.
\end{itemize}

These properties directly match the notion of a spanning tree with degree
constraints, particularly when the degree bound is equal to 2.

\subsection{Construction of the Reduction}

Let $G = (V,E)$ be an arbitrary instance of the Hamiltonian Path problem. From this
instance, a corresponding instance of the DC-MST problem is constructed as follows:

\begin{itemize}
    \item Define $V' = V$.
    \item Define $E' = E$.
    \item For every edge $e \in E'$, assign a unit weight: $w(e) = 1$.
    \item Define the degree bound for all vertices as:
    \[
        b(v) = 2 \quad \forall v \in V'.
    \]
\end{itemize}

The resulting instance consists of the weighted graph
$G' = (V',E',w)$ together with the degree bound function $b$.

\subsection{Correctness of the Reduction}

We now prove that the constructed instance of DC-MST has a solution if and only if
the original instance of Hamiltonian Path has a solution.

\paragraph{Forward implication $(\Rightarrow)$}

Assume that a Hamiltonian path exists in the original graph $G$. By definition, such
a path:

\begin{itemize}
    \item Visits all vertices exactly once.
    \item Is connected and contains no cycles.
    \item Contains exactly $|V|-1$ edges.
\end{itemize}

Moreover, in a Hamiltonian path each vertex has degree at most 2. Therefore, this
path constitutes a valid spanning tree for the DC-MST instance, satisfies all imposed
degree constraints, and its total cost is:

\[
(|V|-1) \cdot 1 = |V|-1.
\]

Consequently, a valid solution exists for the constructed DC-MST instance.

\paragraph{Backward implication $(\Leftarrow)$}

Now assume that a valid solution exists for the constructed DC-MST instance. Such a
solution is a spanning tree $T$ that connects all vertices and satisfies:

\[
\deg_T(v) \leq 2 \quad \forall v \in V'.
\]

A tree in which all vertices have degree at most 2 can only have a path structure.
Acyclicity prevents alternative configurations, and the degree constraint excludes
any branching. Therefore, the tree $T$ defines a simple path that visits all vertices
exactly once.

Consequently, a Hamiltonian path exists in the original graph $G$.

\subsection{Complexity of the Transformation}

The described transformation does not add vertices or edges to the original graph.
The assignment of weights and degree bounds is performed by traversing the sets $V$
and $E$, and thus its time complexity is:

\[
O(|V| + |E|).
\]

Therefore, the reduction is computable in polynomial time.

\subsection{Conclusion}

Since Hamiltonian Path is an NP-complete problem and there exists a polynomial-time
reduction $HP \leq_p DC\text{-}MST$, it follows that the DC-MST problem is
\textbf{NP-hard}. This result provides the theoretical foundation for the approach
adopted in the remainder of this work, which is based on the use of heuristics and
approximation methods.

\section{Algorithm Design}

This section presents the algorithms designed to solve the
\textit{Degree-Constrained Minimum Spanning Tree} (DC-MST) problem. Since in
Section 4 it was shown that the problem is NP-hard, it is not reasonable to
expect the existence of efficient exact algorithms for the general case.
Therefore, a layered approach is adopted, combining exact methods, heuristics,
and iterative improvement techniques.

This approach is consistent with the principles of Design and Analysis of
Algorithms for complex combinatorial optimization problems.

\subsection{General design considerations}

The DC-MST problem generalizes the classical Minimum Spanning Tree (MST)
problem by introducing degree constraints on the vertices. While the MST can
be solved in polynomial time, the additional restriction prevents the direct
application of classical algorithms such as Kruskal’s or Prim’s.

Within this context, the algorithmic design follows three fundamental goals:

\begin{itemize}
    \item Guarantee optimal solutions for small instances (exact algorithm).
    \item Obtain feasible solutions efficiently (greedy heuristic).
    \item Improve solution quality without exploring the entire search space
          (local search).
\end{itemize}

---

\subsection{Exact algorithm by exhaustive enumeration}

\subsubsection{General idea}

The exact algorithm exhaustively explores the space of possible solutions by
enumerating all spanning trees of the graph and selecting the one that satisfies
the degree constraints and has the minimum total cost. This approach guarantees
global optimality of the obtained solution.

\subsubsection{Theoretical foundation}

A spanning tree over a set of $n$ vertices contains exactly $n-1$ edges. The
number of possible spanning trees in a graph can grow exponentially with
respect to $n$, which implies that this approach is not viable for large
instances. Nevertheless, it is useful as a theoretical reference and for
validating heuristic methods.

\subsubsection{Pseudocode}

\begin{algorithm}
\caption{Exact DC-MST by Brute Force}
\begin{algorithmic}[1]
\Require Graph $G=(V,E,w)$, degree bounds $b(v)$
\Ensure Optimal spanning tree $T^*$
\State $T^* \gets \emptyset$
\State $min\_cost \gets +\infty$
\ForAll{spanning trees $T \subseteq E$}
    \If{$\forall v \in V: \deg_T(v) \leq b(v)$}
        \State $cost \gets \sum_{e \in T} w(e)$
        \If{$cost < min\_cost$}
            \State $min\_cost \gets cost$
            \State $T^* \gets T$
        \EndIf
    \EndIf
\EndFor
\Return $T^*$
\end{algorithmic}
\end{algorithm}

---

\subsection{Greedy heuristic with degree constraints}

\subsubsection{Motivation}

Kruskal’s algorithm efficiently solves the MST problem by selecting edges of
minimum cost while avoiding cycles. However, this algorithm does not consider
vertex degree limits. The proposed heuristic adapts this strategy by explicitly
checking degree constraints at each step.

\subsubsection{Greedy strategy}

The heuristic iteratively selects the available edge with minimum weight,
provided that its inclusion does not create a cycle and does not violate the
degree bounds. Although this strategy does not guarantee optimality, it usually
produces good-quality solutions in reasonable time.

\subsubsection{Pseudocode}

\begin{algorithm}
\caption{Greedy Heuristic for DC-MST}
\begin{algorithmic}[1]
\Require Graph $G=(V,E,w)$, degree bounds $b(v)$
\Ensure Feasible spanning tree $T$
\State Sort $E$ in non-decreasing order of $w$
\State Initialize \textsc{Union-Find} structure over $V$
\State $T \gets \emptyset$
\State $\deg(v) \gets 0 \;\; \forall v \in V$
\ForAll{$e=(u,v) \in E$ in increasing order}
    \If{$Find(u) \neq Find(v)$}
        \If{$\deg(u) < b(u)$ \textbf{and} $\deg(v) < b(v)$}
            \State $T \gets T \cup \{e\}$
            \State $Union(u,v)$
            \State $\deg(u) \gets \deg(u)+1$
            \State $\deg(v) \gets \deg(v)+1$
        \EndIf
    \EndIf
\EndFor
\Return $T$
\end{algorithmic}
\end{algorithm}

---

\subsection{Improvement through local search}

\subsubsection{Justification}

Greedy heuristics may become trapped in suboptimal solutions due to early local
decisions. Local search allows exploration of the neighborhood of a feasible
solution, seeking incremental improvements without requiring exhaustive search.

\subsubsection{Neighborhood definition}

The neighborhood of a solution is defined through edge swaps, in which one edge
is removed from the current tree and another external edge is added, preserving
connectivity and degree constraints.

\subsubsection{Pseudocode}

\begin{algorithm}
\caption{Local Search for DC-MST}
\begin{algorithmic}[1]
\Require Initial solution $T$, graph $G=(V,E,w)$, bounds $b(v)$
\Ensure Improved solution $T$
\State $improved \gets$ \textbf{true}
\While{$improved$}
    \State $improved \gets$ \textbf{false}
    \ForAll{$e \in T$}
        \ForAll{$e' \in E \setminus T$}
            \State $T' \gets T - \{e\} + \{e'\}$
            \If{$T'$ is a spanning tree}
                \If{$\forall v: \deg_{T'}(v) \leq b(v)$}
                    \If{$cost(T') < cost(T)$}
                        \State $T \gets T'$
                        \State $improved \gets$ \textbf{true}
                        \State \textbf{break}
                    \EndIf
                \EndIf
            \EndIf
        \EndFor
        \If{$improved$}
            \State \textbf{break}
        \EndIf
    \EndFor
\EndWhile
\Return $T$
\end{algorithmic}
\end{algorithm}

---

\subsection{Metaheuristics for the DC-MST problem}

Since the Degree-Constrained Minimum Spanning Tree problem is NP-hard, even
classical heuristics may become trapped in local optima when facing larger
instances or unfavorable graph structures. For this reason, the incorporation
of metaheuristics is considered, as they allow deeper and more flexible
exploration of the solution space.

Metaheuristics are characterized by introducing global exploration mechanisms,
such as controlled acceptance of worse solutions or the use of memory, while
always maintaining feasibility of the generated solutions. In this work, two
metaheuristics particularly suitable for combinatorial optimization problems on
graphs are implemented: Simulated Annealing and Tabu Search.

\subsubsection{Simulated Annealing}

Simulated Annealing is a metaheuristic inspired by the physical process of
thermal annealing. Its fundamental principle is to allow, with a certain
probability, the acceptance of higher-cost solutions in order to escape local
optima during the early stages of the search.

The algorithm maintains a current solution and generates neighboring solutions
through edge swaps. If the neighboring solution improves the cost, it is
accepted directly. Otherwise, it is accepted with a probability that depends on
the cost increase and on a parameter called temperature, which gradually
decreases throughout the execution.

This strategy enables broad exploration of the solution space at the beginning,
favoring local exploitation as the temperature decreases.

\begin{algorithm}
\caption{Simulated Annealing for DC-MST}
\begin{algorithmic}[1]
\Require Initial solution $T$, graph $G=(V,E,w)$, bounds $b(v)$
\Ensure Best solution found $T^*$
\State $T^* \leftarrow T$
\State Initialize temperature $T_{emp}$
\While{$T_{emp} > T_{min}$}
    \State Generate neighboring solution $T'$
    \If{$T'$ is feasible}
        \If{$cost(T') < cost(T)$}
            \State $T \leftarrow T'$
        \Else
            \State Accept $T'$ with probability $e^{-\Delta / T_{emp}}$
        \EndIf
    \EndIf
    \If{$cost(T) < cost(T^*)$}
        \State $T^* \leftarrow T$
    \EndIf
    \State Update temperature
\EndWhile
\Return $T^*$
\end{algorithmic}
\end{algorithm}

\subsubsection{Tabu Search}

Tabu Search is a local-search-based metaheuristic that incorporates explicit
memory to avoid cycles and redundant exploration. Unlike classical local search,
Tabu Search allows the acceptance of non-improving solutions, provided that the
performed move is not forbidden by the tabu list.

In the context of DC-MST, moves consist of edge swaps. Each recent move is
temporarily stored in a tabu list, preventing its immediate reversal. This
mechanism forces the algorithm to explore new regions of the solution space,
enhancing its global exploration capability.

\begin{algorithm}
\caption{Tabu Search for DC-MST}
\begin{algorithmic}[1]
\Require Initial solution $T$, graph $G=(V,E,w)$, bounds $b(v)$
\Ensure Best solution found $T^*$
\State $T^* \leftarrow T$
\State Initialize tabu list
\For{maximum iterations}
    \State Generate feasible neighborhood of $T$
    \State Select best non-tabu solution $T'$
    \State $T \leftarrow T'$
    \State Update tabu list
    \If{$cost(T) < cost(T^*)$}
        \State $T^* \leftarrow T$
    \EndIf
\EndFor
\Return $T^*$
\end{algorithmic}
\end{algorithm}

\subsection{Synthesis of the algorithmic approach}

The proposed algorithmic design combines exactness, efficiency, and solution
quality. The exact algorithm provides a theoretical reference, the greedy
heuristic ensures scalability, and local search improves solution quality,
achieving an appropriate balance between theoretical rigor and practical
applicability.
\section{Experimental Analysis}

This section presents the experimental study carried out on the algorithms
designed for the \textit{Degree-Constrained Minimum Spanning Tree} (DC-MST) problem.
The main objective is to empirically evaluate the behavior of the algorithms,
contrasting the practical results with the theoretical conclusions obtained in
previous sections.

Since the problem is NP-hard, experimental analysis is essential to understand
the trade-off between optimality, efficiency, and scalability of the proposed
solutions.

---

\subsection{Experimental Methodology}

The experiments were conducted on randomly generated instances using a
parameterizable generator. Each instance is defined by the following parameters:

\begin{itemize}
    \item Number of vertices $|V|$.
    \item Edge existence probability (Erdős--Rényi model).
    \item Edge weight range.
    \item Uniform maximum degree bound $b(v)$.
\end{itemize}

For each experimental configuration, the following algorithms were executed:

\begin{itemize}
    \item Exact brute-force algorithm (only for small instances).
    \item Greedy heuristic with degree constraints.
    \item Local search applied to the greedy solution.
    \item Simulated Annealing, using the greedy heuristic solution as the initial solution.
    \item Tabu Search, applied to the same initial solution, with a fixed-size tabu list.
\end{itemize}

Each execution measures the computation time and the total cost of the obtained
solution. The results were stored in CSV files to facilitate subsequent analysis
and reproducibility.

---

\subsection{Evaluation Metrics}

The metrics used in the experimental analysis are the following:

\begin{itemize}
    \item \textbf{Total cost}: sum of the weights of the edges in the generated tree.
    \item \textbf{Execution time}: computation time measured in seconds.
    \item \textbf{Approximation ratio}: ratio between the cost of a heuristic solution
          and the optimal cost, when the latter is available.
\end{itemize}

These metrics allow evaluating both the quality of the solutions and the
computational efficiency of each approach.

---

\subsection{Experimental Results}

The obtained results confirm the theoretical predictions derived from the
complexity analysis:

\begin{itemize}
    \item The exact algorithm exhibits exponential growth in execution time,
          restricting its use to instances with a small number of vertices.
    \item The greedy heuristic scales efficiently even for larger instances,
          producing feasible solutions in very short times.
    \item Local search systematically improves the cost of the greedy solution,
          approaching the optimum when it is computable.
    \item Simulated Annealing successfully escaped local optima generated by
          classical local search.
    \item Tabu Search provided a more stable exploration of the solution space
          thanks to the use of memory.
\end{itemize}

In instances where it was possible to compute the optimal solution, it was observed
that the approximation ratio of the greedy heuristic is acceptable, and that local
search significantly reduces this gap. The introduced metaheuristics showed superior
performance in terms of solution quality. Both approaches obtained lower-cost
solutions than traditional heuristics, at the expense of higher execution times,
although this increase remained within reasonable limits for medium-sized instances.

---

\subsection{Discussion}

The experimental analysis highlights the classic trade-off between optimality and
efficiency in NP-hard problems. While the exact algorithm guarantees the best
possible solution, its computational cost makes it impractical for real-world
scenarios.

On the other hand, heuristics allow obtaining high-quality solutions in reasonable
times, making them suitable tools for practical applications. Local search proves
to be an effective strategy for refining initial solutions without incurring an
exhaustive exploration of the search space.

These results empirically validate the algorithmic strategy adopted in this work.

---

\subsection{Threats to Validity}

As in any experimental study, certain limitations must be considered:

\begin{itemize}
    \item The use of random instances may not reflect all possible real-world
          scenarios.
    \item Degree constraints were considered uniform, which simplifies some
          practical cases.
    \item The analysis is based on a finite number of instances and parameter
          configurations.
\end{itemize}

Despite these limitations, the experimental design is sufficient to draw valid
conclusions regarding the relative behavior of the evaluated algorithms.

---

\subsection{Experimental Conclusion}

The conducted experiments confirm that the DC-MST problem exhibits a high level of
computational complexity, consistent with its classification as NP-hard. At the
same time, they demonstrate that the combination of greedy heuristics and local
search allows obtaining efficient and high-quality solutions in practice.

These results support the adopted approach and justify the use of approximate
techniques for solving complex network design problems under real-world
constraints.

\section{Future Work}
The work highlights the gap between theoretical optimality and practical efficiency, and demonstrates the usefulness of heuristics for NP-complete problems of real-world relevance.

\end{document}
